\chapter{Implementation Details}
\section{BNFC}
To generate the \textit{ast}, we used the tool BNFC~\cite{bnfc}, and used the
specification in~\cref{lst:bnf} to automatically generate the data types used.

\begin{lstlisting}[frame=single, caption={BNF Specification}, label={lst:bnf}, float, floatplacement=H]
-- Class Declaration

CProgram . Program ::= [ClassDecl] Exp;

CDecl . ClassDecl ::= "class" Id "extends" ClassName "{" [FieldDecl] Constructor [MethodDecl] "}" ;

-- Fields Declaration
FDecl . FieldDecl ::= ClassName Id ";" ;

-- Constructor Declaration
KDecl . Constructor ::= Id "(" [FormalArg] ")" "{" "super" "(" [Argument] ")" ";" [Assignment] "}" ;

FArg . FormalArg ::= ClassName Id;
Arg . Argument ::= Id ;
Assgnmt . Assignment ::= "this" "." Id "=" Id ";" ;

-- Method Declaration
MDecl . MethodDecl ::= ClassName Id "(" [FormalArg] ")" "{" "return" Exp ";" "}" ;

ExpVar . Exp ::= Var ;
ExpFieldAccess . Exp ::= Exp "." Id ; 
ExpMethodInvoc . Exp ::= Exp "." Id "(" [Exp] ")" ;
ExpCast . Exp ::= "(" ClassName ")" Exp ;
ExpNew . Exp ::= "new" Id "(" [Exp] ")" ;

This . Var ::= "this" ;
VarId . Var ::= Id ; 

token Id (letter (letter | digit | '_')*) ;

ClassObject . ClassName ::= "Object" ;
ClassId . ClassName ::= Id ;

separator ClassDecl "" ;
separator FieldDecl "" ;
separator MethodDecl "" ;
separator FormalArg "," ;
separator Argument "," ;
separator Assignment "" ;
separator Exp "," ;
\end{lstlisting}

\section{The Core}
A core set of functionalities were implemented in order to allow set up a
better programing environment. These functions, data and classes would not fit
into the Syntax, Dynamics nor the Type modules, but actually is the core of them all.

They are the Result data, which allow to program using the do notation, the
Referable class which provides a staple implementation for searching in a list.

\subsection{Result Data}
The \texttt{Result} data, which instanciates Monad, this will allow us to
program using the do notation, and to set up fairly nice error messages using
the raise function. The implementation is shown in~\cref{lst:result}.

\begin{lstlisting}[language=Haskell, frame=single, caption={Result Data Implementation}, label={lst:result}, float,floatplacement=H]
type Exception = String

data Result a = Ok a
	| Ex Exception
	deriving(Eq, Show, Ord)

raise :: Exception -> Result a
raise x = Ex x 

instance Monad Result where
	return a = Ok a
	{-(>>=) :: MOut a -> (a -> MOut b) -> MOut b-}
	(>>=) m f = case m of 
				(Ok a) -> f a
				(Ex e) -> raise e
\end{lstlisting}
Most of our implementation functions will return some \texttt{Result a}.

\subsection{Referable Class}

The \texttt{Referable} class provides a default implementation for key
searching in a list. All we need now is to instantiate our classes as a
Referable to use this nice and polimorphic class.  One can think about such a
class as an abstract class in Java, i.e., every class that \texttt{extends} a
given abstract class, will \texttt{inherit} all of its functions. The
implementation for the referable class is shown in~\cref{lst:ref}.

\begin{lstlisting}[language=Haskell, frame=single, caption={The Referable Class Implementation}, label={lst:ref}, float, floatplacement=H]
class Referable a where 
  ref  :: a -> Id
  find :: Id -> [a] -> Result a
 
  find key list = -- defaul implementation
    case [x | x <- list, key == (ref x)] of
      []    -> raise \$ "there is no such a key " ++ show key ++ " in the list."
      (x:_) -> return x  
\end{lstlisting}
      
In~\cref{lst:ref-instance} we provide an example of a Referable instantiation.
In the first line we say that the Var data is an instance of Referable, and we
must provide an implementation for the function ref, which must recieve a Var
and return an Id, as specified above.

\begin{lstlisting}[language=Haskell, frame=single, caption={A referable Instance}, label={lst:ref-instance}, float, floatplacement=H]
instance Referable Var where
  ref This = Id "this"
  ref (VarId id) = id
\end{lstlisting}
Now we are set to use the find function for any \texttt{List of Var}.


