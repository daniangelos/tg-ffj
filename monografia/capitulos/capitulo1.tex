\chapter{Introdução}

\section{Formal Semantics} In this article we are concearned in studying the
formal semantics of programming languages, i.e.\ we are interested in the tools
to understand and reason how programs behave. More specifically the semantics of
Feature Featherweight Java (FFJ).  For historical reasons the semantics of programming
languages is often viewed as consisteing of three strands: 

\begin{itemize} 
    \item \textit{Operational semantics} describes the meaning of the
        programming language by specifying how it executes on an abstract machine;

    \item \textit{Denotational semantics} is a technique for defining the
    meaning of programming languages. At one time called ``mathematical
    semantics'' it uses the more abstract mathematical concepts of complete
    partial orders, continous functions and least fixed points; 

    \item \textit{Axiomatic semantics} tries to fix the meaning of a programming
        contruct by giving proof rules for it whithin a program logic. Thus
        axiomatic semantics emphasises proof of correctness right from the start.
\end{itemize}

It would however be wrong to view these three styles as in opposition to
each other. They each have their uses. A clear operational semantics is very
helpful in implementation. Axiomatic semantics for special kinds of
languages can give strikingly elegant proof systems, useful in developing as
well as verifying programs. Denotational semantics provides the deepest and
most widely applicable thecniques, underpinned by a rich mathematical
theory. Indeed, the different styles  of semantics are highly dependent on
each other. 

For this we will need a nice understanding in logic and set theory.

Com o advento da teoria das provas e da teoria de tipos\cite{martinlof},
ferramentas robustas para prova de corretude de linguagens de computação vêm
sendo introduzidas e melhoradas nas últimas décadas. Entre eles podemos citar
SAT solvers, Provadores de teoremas automatizados e provadores de teoremas
assistidos.  Neste artigo estamos interessados em provadores de teoremas
assistidos, mais especificamente Coq, como ferramenta de auxílio na formalização
da nossa implementação da linguagem \textit{Feature Featherweigth Java} (FFJ),
introduzida nas seções seguintes. 

A formalização pode oferecer impulsos significativos no processo de abstração de
um artefato do mundo real, como, por exemplo, a abstração representada por
linguagens de programação.  Um modelo formal pode ser usado para descrever
alguns aspectos precisos do projeto, para definir e provar suas propriedades,
além de direcionar o foco a questões que poderiam vir a ser negligenciadas.
Estes são alguns dos objetivos que buscamos ao recorrer à formalização de nossa
implementação.

\section{Featherweight Java}

%Como FFJ é construída com base em \textit{Featherweight Java} (FJ),
%introduziremos brevemente as principais características desta linguagem.
The constructions of FFJ are based on the constructions of \textit{Featherweight
Java} (FJ), therefore, we will briefly introduce the main characteristics of
this language.

\textit{Featherweight Java} was proposed by Igarash et.\ al., as a minimal core
calculus for modeling Java's type system~\cite{Igarashi99featherweightjava}. The 
design of this language favors compactness over completeness, having just five 
forms of expression:
\begin{itemize}
    \item object creation
    \item method invocation
    \item field access
    \item casting 
    \item variables
\end{itemize}

The purpose was to omit the maximum number of Java's characteristics while still
maintaina the main core, to ease the formalization model.
There is a direct correspondence between FJ and a purely functional core of
Java, in the sense that every FJ program is literally an executable Java
program.

You can notice that even assignment was omitted as a form of expression (it
appears in field assignment on constructors using \texttt{this}, exclusively), it
follows from this that all fields and method parameters are implicity marked
\texttt{final}. Therefore, FJ is restricted to a ``functional'' fragment of
Java. The authors state that it is easy to encode the lambda calculus to FJ to
prove that it is computationally complete.

%unecessary?
The compactness of FJ is important because the proof of soundness becomes very
simple as the attention can be paid on essential aspects of the language, then
a rigorous soundness proof for even a significant extension of FJ may remain
manageable. This is related to the authors's main goal: to make a proof of type
soundness (``well-typed programs do not get stuck'') as concise as possible, while
still capturing the essence of the soundness argument for the full Java language.

In FJ, a program consists of a collection of class definitions, later on defined
as the class table, and an expression to be evaluated. Here is an example of some typical
class definitions in FJ and a possible expression for this definitions.

\begin{verbatim} 
class A extends Object {
    A() { super(); } 
} 

class B extends Object { 
    B() { super(); }
} 

class Pair extends Object { 
    Object fst; 
    Object snd;
    Pair(Object fst, Object snd) { 
        super(); 
        this.fst = fst; 
        this.snd = snd; 
    } 
    Pair setfst(Object newfst) { 
        return new Pair(newfst, this.snd); 
    } 
} 

new Pair(new A(), new B()).setfst(new B())
\end{verbatim}

\subsection{Syntax}



\subsection{Typing}

\section{Feature Featherweight Java}

This language extends FJ with constructions of \textit{feature-oriented
programming} (FOP) by new languages constructs for feature composition,
according evaluation and type rules.

%FFJ extende FJ com novas construções de linguagem orientados a composição de
%\textit{features}\cite{fop}, avaliação de acordos e regras de
%tipo~\cite{Apel08featurefeatherweight}. Em FFJ, um programador pode adicionar
%novas classes a um programa através da introdução de uma nova característica.


