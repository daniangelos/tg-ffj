\chapter{Introdução}
The main goal of this work is to develop an interpreter for Feature
Featherweight Java, in the future it will be provided a formal proof of its
soundnes in Coq.

But before delving through the definition of FFJ we will first provide
important formal definition to better understand the motivation of our work.

Quando a introducao estiver pronta adicionar aqui uma breve explciacao sobre a
estrutura da introducao.

\section{Abstract Syntax}
Robert Harper in~\cite{practicalFoundations} defines Programming Languages
as means of expressing computations in a form comprehensible to
both people and machines and the syntax of a language specifies the means
by which various sorts of phrases (expressions, commands, declarations, and
so forth) may be combined to form programs.

To better understand the syntax, it is usually introduced a few other auxiliary
concepts, they are \textit{concrete syntax}, \textit{abstract syntax} and
\textit{binding}.
The \textit{surface}, or \textit{concrete syntax} is concerned with how
phrases are entered and displayed on a computer. The \textit{surface
syntax} is usually thought of as given by strings of characters from some
alphabet. 
The \textit{structural}, or \textit{abstract syntax} is concerned
with the structure of phrases, specifically how they are composed from
other phrases. 
At this level a phrase is a tree, called \textit{abstract
syntax tree}, whose nodes are operators that combine several phrases to
form another phrase. The \textit{binding} structure of syntax is concerned
with the introduction and use of identifiers how they are declared, and how
declared identifers are to be used. At  this level phrases are abstract
binding trees, which enrich \textit{abstract syntax} trees with the
concepts of binding and scope.

An \textit{abstract syntax tree}, or \textit{ast} for short, is an
ordered tree whose leaves are variables, and whose interior nodes are
operators whose arguments are its children. A \textit{variable} stands
for an unspecified, or generic piece of syntax of specified sort. Ast's
may be combined by an \textit{operator}, which as an \textit{arity}
specifying the sort of the operator and the number and sorts of its
arguments. 

A variable is an unknown object drawn from some domain. The unknown can
become known by substitution of a particular object for all occurrences of
a variable in a formula, thereby specializing a general formaula to a
particular instance. For example, in school, algebra variables range over
real numbers, say, 7 for x to obtain $7^2 + (2 \times 7) + 1$, which may be
simplified according to the laws of arithmetic to obtain 64, which is
indeed ${(7+1)}^2$ as it ought to be, since $x^2 + 2x + 1 = {(x + 1)}^2$ in
general, and hence in any particular case. The core idea is that \textit{a
variable is an unknown, or a placeholder, whose meaning is given by
susbtition}

As an example, consider a language of arithmetic expressions built from numbers
addition and multiplication. The abstract syntax of such a language consists of
a single sort, Exp, generated by these operations:

\begin{itemize}
    \item An operator num[n] of sort Exp for each n $\in$ N\@;
    \item Two operators, plus and times, of sort Exp, each with two
    arguments of sort Exp.
\end{itemize}

The expression $2+(3 * x)$, which involves a variable $x$, would represent by
the ast $plus(num[2]; times(num[3]; x))$, which is written informally as $2 +
(3 \times 4)$.  

\textit{Abstract binding trees}, or \textit{abt's} enrich ast's with
the means to introduce new variables and symbols, called a
\textit{binding}, with a specified range of significance, called its
\textit{scope}. The scope of a binding is an abt within which the bound
identifier may be used, either as a placeholder (in the case of a
variable declaration) or as the index of some operator (in the case of
a symbol declaration). Thus the set of active identifiers may be larger
within a subtree of an abt than it is within the surrounding tree.
Moreover, different subtrees may introduce identifiers with disjoint
scopes. The crucial principle is that any use of an identifier should
be understood as a reference, or abstract pointer, to its binding. One
consequence is that the choice of identifiers is immaterial, so long as
we can always associate a unique binding with each use of an
identifier.

For an example consider the expression $let x be a_1 in a_2$, which
introduces a variable $x$, for use within the expression $a_2$ to stand
for the expression $a_1$. The variable x is bound by the let expression
for use within $a_2$; any use of $x$ within $a_1$ refers to a different
variable that happens to have the same name. For example, in the
expression $let x be 7 in x+x$ ocurrences of x in the addition refer to
the variable introduced by the let. On the other and in the expression
$let be x*x in x+x$, occurrences of x within the multiplication refer
to a different variable than occurring whithin the addition.

\section{Inductive Definitions}
An inductive definition consists of a set of \textit{rules} for deriving
\textit{judgements}, or \textit{assertion}. Judgments are statements
about one or more abt's of some sort.  The rules specify necessary and
sufficient conditions for the validity of a judgement, and hence
determine its meaning.

As examples of \textit{judgements} we have:

\begin{table}[h!]
    \begin{tabular}{cc}
        $n$ nat & $n$ is a natural number \\
        $n$ = $n_1$ + $n_2$ $n$ & is the sum of $n_1$ and $n_2$\\
        t type & t is a type\\
        e : t & expression e has type t\\
        e || v & expression e has type v
    \end{tabular}
    \caption{}
\end{table}

A judgment states that one or more abstract binding trees have a property
or stand in some relation to one another.

\section{Inference Rules}
An \textit{inductive definition} of a judgment form consists of a collection of \textit{rules} of the form

\begin{mathpar}
    \label{natrules1}
    \inferrule
    {J_1 \and ... \and J_k}
    {J}
\end{mathpar}

in which $J$ and $J_1, ..., J_k$ are all judgments of the form
being defined. The judgments above the horizontal line are called
the \textit{premises} of the rule, and the judgement below the
line is called its \textit{conclusion}. If a rule has no premises
the rule is called an \textit{axiom}; otherwise it is called a
\textit{proper rule}.

For example, the following rules form an inductive definition of the judgement form - nat:

\begin{mathpar}
    \label{natrules2}
    \inferrule
    { }
    {zero \ nat}
\end{mathpar}

\begin{mathpar} 
    \inferrule
    {a \ nat}
    {succ(a) \ nat}
\end{mathpar}

These rules specify that a nat holds whenever either a is zero,
or a is succ(b) where b nat for some b. Taking these rules to be
exhaustive, it follows that a nat iff a is a natural number.

\section{Derivation}
To show that an iductively defined judgement holds, it is enough to exhibit a derivation of it. A derivation of a judgement is a finite composition of rules, starting with axioms and ending with that judgment. It may be thought of as a tree in which each node is a rule whose children are derivations of its premises. We sometimes say that a derivation of J is evidence for the validity of an inductively defined judgement J.

We usually depict derivations as trees with the conclusion at the bottom, and with the children of a node corresponding to a rule appearing above it as evidence for the premises of that rule.

For example, this is a derivation of succ(succ(succ(zero))) nat:

\begin{mathpar}
    \label{natrules}
    \inferrule*
      {\inferrule* 
        {\inferrule* 
          {\inferrule* { } {zero \ nat}}
        {succ(zero)}}
      {succ(succ(zero))}}
    {succ(succ(succ(zero)))}
\end{mathpar}
\ref{natrules}

\section{Type Safety}
FJ and FFJ are \textit{safe} (or, \textit{type safe}, or \textit{strongly
typed}). Informally, this means that certain kinds of mismatches cannot
arise during execution. For example, type safety for E states
that it will never arise that a number is to be added to a
string, or that two
numbers are to be concatenated, neither of which is meaningful.

This means that evaluation cannot get stuck in a state for which no
transition is possible, corresponding in implementation terms to the
absence of "ilegal instruction" errors at execution time. This is proved
by showing that each step of transition can never "go off into the
weeds", and hence can never encounter an illegal instruction.


\section{Formal Semantics} 
In this article we are concearned in studying the formal semantics of
programming languages, i.e.\ we are interested in the tools to understand and
reason how programs behave. More specifically the semantics of Feature
Featherweight Java (FFJ).  For historical reasons the semantics of programming
languages is often viewed as consisteing of three strands: 

\begin{itemize} 
    \item \textit{Operational semantics} describes the meaning of the
        programming language by specifying how it executes on an abstract machine;

    \item \textit{Denotational semantics} is a technique for defining the
    meaning of programming languages. At one time called ``mathematical
    semantics'' it uses the more abstract mathematical concepts of complete
    partial orders, continous functions and least fixed points; 

    \item \textit{Axiomatic semantics} tries to fix the meaning of a programming
        contruct by giving proof rules for it whithin a program logic. Thus
        axiomatic semantics emphasises proof of correctness right from the start.
\end{itemize}

It would however be wrong to view these three styles as in opposition to
each other. They each have their uses. A clear operational semantics is very
helpful in implementation. Axiomatic semantics for special kinds of
languages can give strikingly elegant proof systems, useful in developing as
well as verifying programs. Denotational semantics provides the deepest and
most widely applicable thecniques, underpinned by a rich mathematical
theory. Indeed, the different styles  of semantics are highly dependent on
each other. 

For this we will need a nice understanding in logic and set theory.

Com o advento da teoria das provas e da teoria de tipos\cite{martinlof},
ferramentas robustas para prova de corretude de linguagens de computação vêm
sendo introduzidas e melhoradas nas últimas décadas. Entre eles podemos citar
SAT solvers, Provadores de teoremas automatizados e provadores de teoremas
assistidos.  Neste artigo estamos interessados em provadores de teoremas
assistidos, mais especificamente Coq, como ferramenta de auxílio na formalização
da nossa implementação da linguagem \textit{Feature Featherweigth Java} (FFJ),
introduzida nas seções seguintes. 

A formalização pode oferecer impulsos significativos no processo de abstração de
um artefato do mundo real, como, por exemplo, a abstração representada por
linguagens de programação.  Um modelo formal pode ser usado para descrever
alguns aspectos precisos do projeto, para definir e provar suas propriedades,
além de direcionar o foco a questões que poderiam vir a ser negligenciadas.
Estes são alguns dos objetivos que buscamos ao recorrer à formalização de nossa
implementação.

\section{Featherweight Java}

%Como FFJ é construída com base em \textit{Featherweight Java} (FJ),
%introduziremos brevemente as principais características desta linguagem.
The constructions of FFJ are based on the constructions of \textit{Featherweight
Java} (FJ), therefore, we will briefly introduce the main characteristics of
this language.

\textit{Featherweight Java} was proposed by Igarash et.\ al., as a minimal core
calculus for modeling Java's type system~\cite{Igarashi99featherweightjava}. The 
design of this language favors compactness over completeness, having just five 
forms of expression:
\begin{itemize}
    \item object creation
    \item method invocation
    \item field access
    \item casting 
    \item variables
\end{itemize}

The purpose was to omit the maximum number of Java's characteristics while still
maintain a the main core, to ease the formalization model.
There is a direct correspondence between FJ and a purely functional core of
Java, in the sense that every FJ program is literally an executable Java
program.

%p: avoid using parenthesis, it is harder to understand 
%p: maybe we should consider explaining this after the example, then we can
%point to the constructor and everythings makes sense
Notice that FJ doesn't even allow assignment as a form of expression.
Assignment is used exclusively in field assignment inside the  constructors
using \texttt{this}. Thus all fields and method parameters are implicity marked
\texttt{final}. Therefore, FJ is restricted to a ``functional'' fragment of
Java. The authors state that it is easy to encode the lambda calculus to FJ to
prove that it is computationally complete.

%d: unecessary?
%p: I think it is ok
The compactness of FJ is important because the soundness proof becomes very
simple as the attention can be paid on essential aspects of the language, then
a rigorous soundness proof for even a significant extension of FJ remains
manageable. This is related to the authors's main goal: to make a proof of type
soundness (``well-typed programs do not get stuck'') as concise as possible, while
still capturing the essence of the soundness argument for the full Java language.

In FJ, a program consists of a collection of class definitions, later on defined
as the class table, and an expression to be evaluated. Here is an example of some typical
class definitions in FJ and a possible expression for this definitions.

\begin{verbatim} 
class A extends Object {
    A() { super(); } 
} 

class B extends Object { 
    B() { super(); }
} 

class Pair extends Object { 
    Object fst; 
    Object snd;
    Pair(Object fst, Object snd) { 
        super(); 
        this.fst = fst; 
        this.snd = snd; 
    } 
    Pair setfst(Object newfst) { 
        return new Pair(newfst, this.snd); 
    } 
} 

new Pair(new A(), new B()).setfst(new B())
\end{verbatim}

\subsection{Syntax}



\subsection{Typing}

\section{Feature Featherweight Java}

This language extends FJ with constructions of \textit{feature-oriented
programming} (FOP) by new languages constructs for feature composition,
according evaluation and type rules.

%FFJ extende FJ com novas construções de linguagem orientados a composição de
%\textit{features}\cite{fop}, avaliação de acordos e regras de
%tipo~\cite{Apel08featurefeatherweight}. Em FFJ, um programador pode adicionar
%novas classes a um programa através da introdução de uma nova característica.


