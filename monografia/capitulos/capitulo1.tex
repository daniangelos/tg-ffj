\chapter{Introdução}

\section{Formal Semantics} In this article we are concearned in studying the
formal semantics of programming languages, i.e.\ we are interested in the tools
to understand and reason how programs behave. More specifically the semantics of
Feature Featherweight Java.  For historical reasons the semantics of programming
languages is often viewed as consisteing of three strands: 

\begin{itemize} 
    \item \textit{Operational semantics} describes the meaning of the
        programming language by specifying how it executes on an abstract machine;

    \item \textit{Denotational semantics} is a technique for defining the
    meaning of programming languages. At one time called ``mathematical
    semantics'' it uses the more abstract mathematical concepts of complete
    partial orders, continous functions and least fixed points; 

    \item \textit{Axiomatic semantics} tries to fix the meaning of a programming
        contruct by giving proof rules for it whithin a program logic. Thus
        axiomatic semantics emphasises proof of correctness right from the start.
\end{itemize}

It would however be wrong to view these three styles as in opposition to
each other. They each have their uses. A clear operational semantics is very
helpful in implementation. Axiomatic semantics for special kinds of
languages can give strikingly elegant proof systems, useful in developing as
well as verifying programs. Denotational semantics provides the deepest and
most widely applicable thecniques, underpinned by a rich mathematical
theory. Indeed, the different styles  of semantics are highly dependent on
each other. 

For this we will need a nice understanding in logic and set theory.

Com o advento da teoria das provas e da teoria de tipos\cite{martinlof},
ferramentas robustas para prova de corretude de linguagens de computação vêm
sendo introduzidas e melhoradas nas últimas décadas. Entre eles podemos citar
SAT solvers, Provadores de teoremas automatizados e provadores de teoremas
assistidos.  Neste artigo estamos interessados em provadores de teoremas
assistidos, mais especificamente Coq, como ferramenta de auxílio na formalização
da nossa implementação da linguagem \textit{Feature Featherweigth Java} (FFJ),
introduzida nas seções seguintes. 

A formalização pode oferecer impulsos significativos no processo de abstração de
um artefato do mundo real, como, por exemplo, a abstração representada por
linguagens de programação.  Um modelo formal pode ser usado para descrever
alguns aspectos precisos do projeto, para definir e provar suas propriedades,
além de direcionar o foco a questões que poderiam vir a ser negligenciadas.
Estes são alguns dos objetivos que buscamos ao recorrer à formalização de nossa
implementação.

    \section{Coq} Coq é um provador de teoremas automatizado  baseado na
    linguagem formal Calculo de Construções Indutivas\cite{coqart}, o qual em si
    mesmo combina tanto lógica de ordem superior quanto uma linguagem funtional
    ricamente-tipada. Através de uma linguagem vernacular de comandos, Coq
    permite: \begin{itemize} \item definir funções ou predicados, que podem ser
    avaliados eficientemente; \item declarar teoremas matemáticos e
    especificações de software; \item desenvolver provas formas destes teoremas
    de forma iterativa; \item checar estas provas por uma certificação de
    kernell relativamente pequena; \item extrair programas certificados para
    Objective Caml, Haskell ou Scheme.  \end{itemize} Como um sistema de
    desenvolvimento de provas, Coq provê métodos de provas iterativos,
    algoritmos de decisão e semi-decisão, e uma linguagem de tatica que permite
    o usuário definir seus próprios métodos de prova. Conexão com uma
    calculadora de sistema algébrico externo e outros provadores de teoremas
    está disponível.  Como uma plataforma de formalização matemática ou de
    desenvolvimento de programas, coq provê suporte para notações de alta ordem,
    conteúdos implicitos e vários outros tipos úteis de macros.

\section{Featherweight Java}

%Como FFJ é construída com base em \textit{Featherweight Java} (FJ),
%introduziremos brevemente as principais características desta linguagem.
The constructions of FFJ are based on the constructions of \textit{Featherweight
Java} (FJ), therefore, we will briefly introduce the main characteristics of
this language.

\textit{Featherweight Java} was proposed by Igarash et.\ al., as a minimal core
calculus for modeling Java's type system~\cite{Igarashi99featherweightjava}. The 
design of this language favors compactness over completeness, having just five 
forms of expression: object creation, method invocation, field access, casting
and variables.
The purpose was to omit the maximum number of Java's characteristics while still
maintaina the main core, to ease the formalization model.
There is a direct correspondence between FJ and a purely functional core of
Java, in the sense that every FJ program is literally an executable Java
program.

%unecessary?
The compactness of FJ is important because the proof of soundness becomes very
simple as the attention can be paid on essential aspects of the language, then
a rigorous soundness proof for even a significant extension of FJ may remain
manageable. This is related to the authors's main goal: to make a proof of type
soundness (``well-typed programs do not get stuck'') as concise as possible, while
still capturing the essence of the soundess argument for the full Java language.

In FJ, a program consists of a collection of class definitions, later on defined
as a class table, and an expression to be evaluated. Here is an example of some typical
class definitions in FJ and a possible expression for this definitions.

\begin{verbatim} 
class A extends Object {
    A() { super(); } 
} 

class B extends Object { 
    B() { super(); }
} 

class Pair extends Object { 
    Object fst; 
    Object snd;
    Pair(Object fst, Object snd) { 
        super(); 
        this.fst = fst; 
        this.snd = snd; 
    } 
    Pair setfst(Object newfst) { 
        return new Pair(newfst, this.snd); 
    } 
} 

new Pair(new A(), new B()).setfst(new B())

\end{verbatim}

    

\section{Feature Featherweight Java}

FFJ extende FJ com novas construções de linguagem orientados a composição de
\textit{features}\cite{fop}, avaliação de acordos e regras de
tipo~\cite{Apel08featurefeatherweight}. Em FFJ, um programador pode adicionar
novas classes a um programa através da introdução de uma nova característica.
    
%texto.... referência~\cite{carpenter91}








