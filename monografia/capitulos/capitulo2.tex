\chapter{Implementation details}

\section{Why Haskell?}

Haskell is a general purpose programming language. It wasdesigned without any
application niche in mind, i.e., it does not favour one problem domain over
others. While at its core, Haskell encourages, as a default, a pure, lazy style of
functional programming, but it's not the only option. It also supports the more
traditional models of procedural code code and strict evaluation. The focus of
the language is on writing statically typed programs~\cite{rwhaskell}. 

\section{BNFC}
\textit{Backus-Naur Form}, also know as Context-Free Grammars,
\textit{Converter} (BNFC) is a tool developded to help the design and
implementation of a new programming language~\cite{bnfcsite}. 
It uses the grammar formalism named \textit{Labelled BNF} (LBNF) defined
in~\cite{bnfc}. Given a grammar written in LBNF, the BNFC produces a complete
compiler front end (with no type checking), i.e. a lexer, a parser, and an
abstract syntax definition. Moreover, it also provides a pretty-printer and a
language specification \LaTeX as well as a template file for the compiler back
end. Since LBNF is purely declarative, these files can be generated in any
programming language that supports appropriate compiler front-end tools, in
particular, Haskell.

\subsection{Basic LBNF}

\begin{verbatim}
EPlus. Exp ::= Exp "+" Num ;
ENum. Exp ::= Num ;
NOne. Num ::= 1 ;
\end{verbatim}

\section{Monads}

The functional programming community divides into two camps~\cite{monadswadler}.
\textit{Pure} languages, such as Haskell, are lambda calculus pure and simple.
\textit{Impure} languages extends lambda calculus with a number of possible
effects. Pure languages are easier to reason about and may benefit from lazy
evaluation, while the impure ones offer efficiency benefits and sometimes make
possible a more compact mode of expression. 

It has been discussed the difficulties of implementing a evaluator in a pure
functional language, it basically envolves:
\begin{itemize}
\item To add error handling to it, it is necessary to modify each recursive call to
check for and handle errors appropriately, a work easily done with exceptions in
an impure language
\item To add a count of operations performed, we must modify each
recursive call to pass around such counts appropriately, this would be easily
done in an impure language using global variables
\item To add an execution trace to it, we need to modify each recursive call to
pass aroung such traces, also easily done in an impure language
\end{itemize}

The solution: \textit{monad}.

\section{Coq} 
Coq is a formal proof management system based on the Calculus of Inductive
Constructions~\cite{coqart}. It provides a formal language to write mathematical
definitions, executable algorithms and theorems together with an environment
that combines superior order logic and a dependently typed functional language.
Coq allows you to, with this language~\cite{coqsite}:
\begin{itemize}
\item define functions or predicates, that can be efficiently evaluated
\item declare mathemematical theorems and software specifcations
\item develop formal proofs
\item check these proofs by a certificate ``kernel''
\item extract certified programs to some functional programming languages
\end{itemize}


\iffalse
Coq é um provador de teoremas automatizado baseado na
linguagem formal Calculo de Construções Indutivas\cite{coqart}, o qual em si
mesmo combina tanto lógica de ordem superior quanto uma linguagem funtional
ricamente-tipada. Através de uma linguagem vernacular de comandos, Coq
permite: \begin{itemize} \item definir funções ou predicados, que podem ser
avaliados eficientemente; \item declarar teoremas matemáticos e
especificações de software; \item desenvolver provas formas destes teoremas
de forma iterativa; \item checar estas provas por uma certificação de
kernel relativamente pequena; \item extrair programas certificados para
Objective Caml, Haskell ou Scheme.  \end{itemize} Como um sistema de
desenvolvimento de provas, Coq provê métodos de provas iterativos,
algoritmos de decisão e semi-decisão, e uma linguagem de tatica que permite
o usuário definir seus próprios métodos de prova. Conexão com uma
calculadora de sistema algébrico externo e outros provadores de teoremas
está disponível.  Como uma plataforma de formalização matemática ou de
desenvolvimento de programas, coq provê suporte para notações de alta ordem,
conteúdos implicitos e vários outros tipos úteis de macros.
\fi










