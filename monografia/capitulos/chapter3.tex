\chapter{Implementation Decisions}

In this chapter we will discuss the tools chosen for implementing the project
and why. In the first section we explain why haskell and how it's features may
help us to accomplish our first goal which is building an interpreter. In the
second section we give a mild introduction to BNF. The third section is about a
very important haskell feature which is called monads, and allows to simulate
side effects. The fourth section is about coq which will be used to provide the
soundess proof later on.

\section{DSLs}
The first problem to address was to find a suitable programming language to
model Domain Specific Languages (DSL). In short DSLs are programming languages
specialized to a particular application domain. In our case our domain will be
the interpreter and our specialization will be an \textit{ast}. Haskell is a
great host for DSLs because of flexible overloading, a powerful type system,
and lazy semantics~\cite{gill2014domain}. 

\section{Haskell}
Haskell is a general purpose programming language. It was designed without any
application niche in mind, i.e., it does not favour one problem domain over
others. While at its core, Haskell encourages, as a default, a pure, lazy style
of functional programming, but it's not the only option. It also supports the
more traditional models of procedural code code and strict evaluation. The
focus of the language is on writing statically typed programs~\cite{rwhaskell}. 

\subsection{Quick tutorial}
In Haskell is all about \textit{types}. Types, like those in other languages,
are constraining summaries of structural values. For example, in Haskell
\texttt{Bool} is tye type of the values \texttt{False}; \texttt{Int} is the
type of machinezed sized words; \texttt{Double} is the type of double
preceision IEEE floating-point values; and this list goes on the same manner as
C, C+++, Java, and other traditional languages. All of these type names in
haskell start with an upper case letter.

On top of these basic types, Haskell has two syntactic forms for expressing
compund types. First, pairs, triples, and larger structures can be written
using tuple-syntax, comma-separated types inside parentheses. Thus,
(\texttt{Int}, \texttt{Bool}) is a structures with both an \texttt{Int} and a
\texttt{Bool} component. Second, lists have a syntactic shortcut, using square
brackets. Thus, [\texttt{Int}] is a list of \texttt{Int}.

There are also other container types. A container that may contain one Int has
the type \texttt{Maybe Int}, which is read Maybe of Int. These container names
also start with upper case letters.

Types can be nested to any depth. For example, you can have a
[(\texttt{Maybe}(\texttt{Int}, \texttt{Bool}))], read as list of maybe of (Int
and Bool).

Polymorphic values are expressed using lowercase letters and play a similar
role to \texttt{void*} pointers in C and polymorphic arguments in the Java
generics facility. These polymorphic values can have constraints expressed over
them, using the haskell equivalent of an object hierarchy.

Finally, a function is written using an arrow from argument type to result
type. Thus, in Haskell, a function that takes a list and returns a list is
writen as: \texttt{[a] -> [a]}.

Here is an example of a Haskell function:

\begin{lstlisting}[language=Haskell]
sort :: (Ord a) => [a] -> [a]
sort [] = []
sort (x:xs) = sort before
    ++ [x] ++ sort after
  where 
    before = filter (<= x) xs
    after = filter (>x) xs
\end{lstlisting}

This function sorts a list using a variant of quicksort which the pivot is the first element of the list:
\begin{itemize} 
\item The first line of the type for \texttt{sort}. This is $\forall a$, such
that $a$ can be ordered (i.e. admits comparisons like \texttt{<=}); the
function takes and return a list of such $a$s.  
\item The second line says that an empty list is already sorted.  
\item The remaining lines state that a non-empty list can be sorted by taking
the first and rest of the list (called \texttt{x} and \texttt{xs},
respectively), sorting the values before this pivot and after this pivot, and
concatenating these intermediate values together.  
\item Finally, intermediate values can be named using the where syntax; in this
case the values of \texttt{before} and \texttt{after}.
\end{itemize}

Haskell is a concise and direct language. Structures in Haskell are denoted
using types, constructed and deconstructed, but never updated. For example, the
\texttt{Maybe} type can be defined using two Constructors, \texttt{Nothing} and
\texttt{Just}:

\begin{lstlisting}[language=Haskell]
data Maybe where
    Nothing ::  Maybe a
    Just    ::  a -> Maybe a
\end{lstlisting}

\texttt{Nothing} is a \texttt{Maybe} of anything; \texttt{Just}, with an
argument, is a maybe with the type of the argument. These constructors can be
used to construct and deconstruct structures, but there is never any updating;
all structures in Haskell are immutable.

It is possible to give specific types extra powers, such as equality and
comparison, using the class-based overloading system. The \texttt{Maybe} type,
for example, can be given the ability to test for equality, using an instance:

\begin{lstlisting}[language=Haskell]
instance Eq a => Eq (Maybe a)
  where
    Just a == Just b = a == b
    Nothing == Nothing = True
    _ == _ = False
\end{lstlisting}

This states that for any type that can be tested for equality, you can also
check \texttt{Maybe} of the same type. You take the \texttt{Maybe} apart, using
pattern matching on \texttt{Just}, to check the internal value.


\section{BNFC}
\textit{Backus-Naur Form}, also know as Context-Free Grammars,
\textit{Converter} (BNFC) is a tool developded to help the design and
implementation of a new programming language~\cite{bnfcsite}. 
It uses the grammar formalism named \textit{Labelled BNF} (LBNF) defined
in~\cite{bnfc}. Given a grammar written in LBNF, the BNFC produces a complete
compiler front end (with no type checking), i.e. a lexer, a parser, and an
abstract syntax definition. Moreover, it also provides a pretty-printer and a
language specification \LaTeX as well as a template file for the compiler back
end. Since LBNF is purely declarative, these files can be generated in any
programming language that supports appropriate compiler front-end tools, in
particular, Haskell.

\subsection{Basic LBNF}

Briefly, an LBNF grammar is a context-free grammar where every rule is given a
label. The label is used for constructing a syntax tree whose subtrees are
given by the nonterminals of the rule, in the same order.

As an example of LBNF, consider a triple of rules defining addition expressions
with ``1''.

\begin{verbatim}
EPlus. Exp ::= Exp "+" Num ;
ENum. Exp ::= Num ;
NOne. Num ::= 1 ;
\end{verbatim}

From an LBNF grammar, the BNFC extracts an abstract syntax and a concrete
syntax. In Haskell, for instance, the abstract syntax is implemented asa system
of datatype definitions.

\begin{verbatim}
data Exp = EPlus Exp Exp | ENUm Num
data Num = NOne
\end{verbatim}

\section{Monads}

The functional programming community divides into two camps~\cite{monadswadler}.
\textit{Pure} languages, such as Haskell, are lambda calculus pure and simple.
\textit{Impure} languages extends lambda calculus with a number of possible
effects. Pure languages are easier to reason about and may benefit from lazy
evaluation, while the impure ones offer efficiency benefits and sometimes make
possible a more compact mode of expression. 

It has been discussed the difficulties of implementing a evaluator in a pure
functional language, it basically envolves:
\begin{itemize}
\item To add error handling to it, it is necessary to modify each recursive call to
check for and handle errors appropriately, a work easily done with exceptions in
an impure language
\item To add a count of operations performed, we must modify each
recursive call to pass around such counts appropriately, this would be easily
done in an impure language using global variables
\item To add an execution trace to it, we need to modify each recursive call to
pass aroung such traces, also easily done in an impure language
\end{itemize}

The solution: \textit{monad}.

\section{Coq} 
Coq is a formal proof management system based on the Calculus of Inductive
Constructions~\cite{coqart}. It provides a formal language to write mathematical
definitions, executable algorithms and theorems together with an environment
that combines superior order logic and a dependently typed functional language.
Coq allows you to, with this language~\cite{coqsite}:
\begin{itemize}
\item Define functions or predicates, that can be efficiently evaluated;
\item Declare mathemematical theorems and software specifcations;
\item Develop formal proofs;
\item Check these proofs by a certificate ``kernel'';
\item Extract certified programs to some functional programming languages
\end{itemize}


\iffalse
Coq é um provador de teoremas automatizado baseado na
linguagem formal Calculo de Construções Indutivas\cite{coqart}, o qual em si
mesmo combina tanto lógica de ordem superior quanto uma linguagem funtional
ricamente-tipada. Através de uma linguagem vernacular de comandos, Coq
permite: \begin{itemize} \item definir funções ou predicados, que podem ser
avaliados eficientemente; \item declarar teoremas matemáticos e
especificações de software; \item desenvolver provas formas destes teoremas
de forma iterativa; \item checar estas provas por uma certificação de
kernel relativamente pequena; \item extrair programas certificados para
Objective Caml, Haskell ou Scheme.  \end{itemize} Como um sistema de
desenvolvimento de provas, Coq provê métodos de provas iterativos,
algoritmos de decisão e semi-decisão, e uma linguagem de tatica que permite
o usuário definir seus próprios métodos de prova. Conexão com uma
calculadora de sistema algébrico externo e outros provadores de teoremas
está disponível.  Como uma plataforma de formalização matemática ou de
desenvolvimento de programas, coq provê suporte para notações de alta ordem,
conteúdos implicitos e vários outros tipos úteis de macros.
\fi










